#! /bin/bash
### BEGIN INIT INFO
# Provides:          dataconnector
# Required-Start:    $local_fs $network $remote_fs
# Required-Stop:     $local_fs $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      S 0 1 6
# Short-Description: Start secure link client
# Description:       Basic stop/start commands for dataconnector.
#                    Provides a wrapper for the java application suitable for
#                    linux systems. Startup options will improve as the
#                    dataconnector client develops.
### END INIT INFO

# Author: Sebastian Welsh <sebastianw@google.com>

# Do NOT "set -e"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/usr/sbin:/usr/bin:/sbin:/bin
DESC="Securelink client for Google Apps"
NAME="dataconnector"

JVM_ARGS="-Djava.net.preferIPv4Stack=true"
CLIENT="com.google.dataconnector.client.Client"
SECURELINK_HOME="/opt/dataconnector"
CLASSPATH=\
$SECURELINK_HOME/third-party/jsocks/jsocks-server.jar:\
$SECURELINK_HOME/third-party//wpg-proxy/bin/wpgproxy.jar:\
$SECURELINK_HOME/third-party/jline/jline-0.9.91.jar:\
$SECURELINK_HOME/third-party/commons-io/commons-io-1.3.2.jar:\
$SECURELINK_HOME/third-party/jsch/jsch-20071024.jar:\
$SECURELINK_HOME/third-party/apache-log4j/log4j-1.2.15.jar:\
$SECURELINK_HOME/third-party/commons-logging/commons-logging-1.1.jar:\
$SECURELINK_HOME/third-party/commons-cli/commons-cli-1.1.jar:\
$SECURELINK_HOME/third-party/aopalliance/aopalliance.jar:\
$SECURELINK_HOME/third-party/guice-snapshot20081016/guice-assistedinject-snapshot20081016.jar:\
$SECURELINK_HOME/third-party/guice-snapshot20081016/guice-snapshot20081016.jar:\
$SECURELINK_HOME/third-party/json/json.jar:\
$SECURELINK_HOME/third-party/oauth/core.jar:\
$SECURELINK_HOME/third-party/oauth/commons-codec-1.3.jar:\
$SECURELINK_HOME/third-party/google-feedserver/commons-beanutils-1.8.0.jar:\
$SECURELINK_HOME/third-party/google-feedserver/commons-beanutils-core-1.8.0.jar:\
$SECURELINK_HOME/third-party/google-feedserver/gdata-client-1.0.jar:\
$SECURELINK_HOME/third-party/google-feedserver/gdata-core-1.0.jar:\
$SECURELINK_HOME/third-party/google-feedserver/google-feedserver-java-client-1.0.jar:\
$SECURELINK_HOME/third-party/google-feedserver/commons-lang-2.4.jar:\
$SECURELINK_HOME/classes/

CONFIG="/etc/opt/dataconnector/localConfig.xml"
RULES="/etc/opt/dataconnector/resourceRules.xml"
LOGGING="/etc/opt/dataconnector/logging.properties"
KEY="/etc/opt/dataconnector/secureLinkClientTrustStore"
KEY_PASS="woodstock"
SERVER="74.125.39.192"
PORT="443"
LOGFILE="/var/log/dataconnector/dataconnector"

OPTIONS="-localConfigFile $CONFIG -rulesFile $RULES"

DAEMON="/usr/bin/java"
USER=dataconnector
DAEMON_ARGS="$JVM_ARGS -classpath $CLASSPATH $CLIENT $OPTIONS"
PIDFILE=/var/run/$NAME
RULES_FILE=/var/opt/$NAME/rules
SCRIPTNAME=/etc/init.d/$NAME

START_MARKER="-- Starting dataconnector --"
STOP_MARKER="-- Stopped dataconnector --"

START_TIMEOUT=15

# Exit if java is not installed
[ -x /usr/bin/java ] || exit 0

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# Load the VERBOSE setting and other rcS variables
[ -f /etc/default/rcS ] && . /etc/default/rcS

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions


is_running()
{
  # Returns
  # 0 if the service is running
  # 1 if the service is not running
  if [[ -e $PIDFILE ]]; then
    read pid < $PIDFILE
    # There should be a java process running with this PID
    ps -o "args=" $pid | grep -q "java .* $CLIENT" && return 0
    # Otherwise the service is dead. Remove the pidfile
    rm $PIDFILE && return 1
  else
    return 1
  fi
}


get_rules()
{
  # Sweep back through the log to find the most recently registered rules.
  rule_match="ClientRegistrationUtil  - Registering rules: (.*)"
  rules=$(tac "$LOGFILE" | while read line; do
    [[ "$line" =~ $rule_match ]] && echo ${BASH_REMATCH[1]} && break
    # Only process the log until we get to the previous session.
    [[ "$line" =~ "$START_MARKER" || "$line" =~ "$STOP_MARKER" ]] && break
  done)
  echo $rules
}

check_startup()
{
  # At the moment, checking startup can only be done by examining the logs.
  # Look for some key events within a reasonable startup period (15s)
  # Client startup events occur in this sequence:
  # - Start HTTP proxy
  # - Connect to WTS server
  # - Start socks proxy
  # - Authenticate to WTS
  # - Register rules
  # - Start ssh
  # - Swap in ssh for TLS
  # Look through the log for these events in reverse order: All must be
  # successful for the client to have started successfully.
  # Return the following at the end of the startup period:
  # - 0: Startup complete
  # - 1: Startup failed

  # There are 6 things to check- set a unique value for each so we can get a
  # meaningful error state
  status=(1 2 4 8 16 32)
  declare -i result=0

  # Go from the bottom of the logfile:
  # First, set some match variables. Do this, rather than inline, as bash
  # escapes pattern operators (E14 in the bash FAQ)
  match1="com.wpg.proxy.Proxy  - Proxy started on:"
  match2="Starting SOCKS Proxy on:"
  match3="ClientRegistrationUtil  - Login .* successful"
  match4="ClientRegistrationUtil  - Registration .* successful"
  match5="SecureDataConnection  - Login successful as"
  match6="Connecting SSHD to existing stream"
  # TODO(sebastian): add failure conditions as well.
  # Annoyingly, read spawns a subshell, which means that the parsing results
  # get dropped and I can't return the status array. The easy workaround it to
  # simply print it out as a bunch of numbers and capture it into a new
  # variable.
  declare -i timer=0
  while [[ timer -lt $START_TIMEOUT ]] ; do
    result=0
    response=$(tac "$LOGFILE" | \
      while read line; do
        [[ "$line" =~ $match1 ]] && status[0]=0
        [[ "$line" =~ $match2 ]] && status[1]=0
        [[ "$line" =~ $match3 ]] && status[2]=0
        [[ "$line" =~ $match4 ]] && status[3]=0
        [[ "$line" =~ $match5 ]] && status[4]=0
        [[ "$line" =~ $match6 ]] && status[5]=0
        # Only process the log until the start of this session
        [[ "$line" =~ "$START_MARKER" ]] && echo ${status[@]} && break
        # If we get here, the client failed to start normally.
        [[ "$line" =~ "$STOP_MARKER" ]] && echo 128 && break
      done)
    for i in $response; do
      result+=${i}
    done
    # Results we should exit on:
    # - 0:  means all tests passed.
    # - 128: a processing error occurred.
    if [[ $result -eq 0 ]]; then  # SUCCESS- all checks passed
      return 0
    elif [[ $result -eq 128 ]]; then  # HORROR- an error has caused ruin
      return 1
    else  # PATIENCE- keep on truckin'
      timer+=1
      sleep 1
    fi
  done
  return 1
}


#
# Function that starts the daemon/service
#
do_start()
{
  start_cmd="nohup $DAEMON $DAEMON_ARGS >> $LOGFILE 2>&1"
  # Return
  #   0 if daemon has been started
  #   1 if daemon was already running
  #   2 if daemon could not be started
  is_running
  case "$?" in
    0)# Is already running.
      return 1
      ;;
    1)# Is not running. Start it.
      [[ -e $PIDFILE ]] && rm $PIDFILE
      echo $START_MARKER >> $LOGFILE
      # Starts the dataconnector client backgrounded and returns its PID
      sudo -u $USER /bin/bash -c "$start_cmd & echo \$! " > $PIDFILE
      # Make sure the client started
      if [[ is_running ]]; then
        # Monitor the startup logs to confirm the agent connected OK.
        check_startup
        started_ok=$?
        if [[ $started_ok ]]; then
          get_rules > $RULES_FILE
          return 0
        fi
      fi
      # Fall through if it's not running, or the startup checks fail.
      do_stop
      return 2
      ;;
  esac
}

#
# Function that stops the daemon/service
#
do_stop()
{
  # Return
  #   0 if daemon has been stopped
  #   1 if daemon was already stopped
  #   2 if daemon could not be stopped
  is_running
  case "$?" in
    0) read pid < $PIDFILE
       kill $pid
       case "$?" in
         0) [[ -e $PIDFILE ]] && rm $PIDFILE
            echo $STOP_MARKER >> $LOGFILE
            # Sterilise the rules file
            echo '' > $RULES_FILE
            return 0
            ;;
         *) echo "Stopping $pid failed" >> $LOGFILE
            return 2
            ;;
       esac
       ;;
    1) echo $STOP_MARKER >> $LOGFILE
       return 1
       ;;
    2) [[ -e $PIDFILE ]] && rm $PIDFILE
       return 1
       ;;
  esac
}

case "$1" in
  start)
    [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
    do_start
    case "$?" in
      0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
      2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
    esac
    ;;
  stop)
    [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
    do_stop
    case "$?" in
      0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
      2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
    esac
    ;;
  restart|force-reload)
    log_daemon_msg "Restarting $DESC" "$NAME"
    do_stop
    case "$?" in
      0|1)
        sleep 2
        do_start
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1 ;; # Old process is still running
          *) log_end_msg 2 ;; # Failed to start
        esac
        ;;
      *)
        # Failed to stop
        log_end_msg 1
        ;;
    esac
    ;;
  status)
    log_daemon_msg "Checking $DESC" "$NAME"
    is_running
    case "$?" in
      0) log_end_msg 0 ;;
      1) log_end_msg 1
         exit 1
         ;;
    esac
    ;;
  get_rules)
    get_rules
    ;;
  *)
    echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload|get_rules}" >&2
    exit 3
    ;;
esac

:
